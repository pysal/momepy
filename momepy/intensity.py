#!/usr/bin/env python
# -*- coding: utf-8 -*-

# intensity.py
# definitons of intensity characters

from tqdm import tqdm  # progress bar
import pandas as pd
import numpy as np
import collections


def covered_area_ratio(objects, look_for, area_column, look_for_area_column, id_column="uID"):
    """
    Calculate covered area ratio of objects.

    .. math::
        \\textit{covering object area} \over \\textit{covered object area}

    Parameters
    ----------
    objects : GeoDataFrame
        GeoDataFrame containing objects being covered (e.g. land unit)
    look_for : GeoDataFrame
        GeoDataFrame with covering objects (e.g. building)
    area_column : str
        name of the column of objects gdf where is stored area value
    look_for_area_column : str
        name of the column of look_for gdf where is stored area value
    id_column : str
        name of the column with unique id. If there is none, it could be generated by unique_id().

    Returns
    -------
    Series
        Series containing resulting values.

    References
    ---------

    """
    print('Calculating covered area ratio...')

    print('Merging DataFrames...')
    look_for = look_for[[id_column, look_for_area_column]]  # keeping only necessary columns
    look_for.rename(index=str, columns={look_for_area_column: 'lf_area'}, inplace=True)
    objects_merged = objects.merge(look_for, on=id_column)  # merging dataframes together

    print('Calculating CAR...')

    # define empty list for results
    results_list = []

    # fill new column with the value of area, iterating over rows one by one
    for index, row in tqdm(objects_merged.iterrows(), total=objects_merged.shape[0]):
        results_list.append(row['lf_area'] / row[area_column])

    series = pd.Series(results_list)

    print('Covered area ratio calculated.')
    return series


def floor_area_ratio(objects, look_for, area_column, look_for_area_column, id_column="uID"):
    """
    Calculate floor area ratio of objects.

    .. math::
        \\textit{covering object floor area} \over \\textit{covered object area}

    Parameters
    ----------
    objects : GeoDataFrame
        GeoDataFrame containing objects being covered (e.g. land unit)
    look_for : GeoDataFrame
        GeoDataFrame with covering objects (e.g. building)
    area_column : str
        name of the column of objects gdf where is stored area value
    look_for_area_column : str
        name of the column of look_for gdf where is stored floor area value
    id_column : str
        name of the column with unique id. If there is none, it could be generated by unique_id().

    Returns
    -------
    Series
        Series containing resulting values.

    References
    ---------

    """
    print('Calculating floor area ratio...')

    print('Merging DataFrames...')
    look_for = look_for[[id_column, look_for_area_column]]  # keeping only necessary columns
    look_for.rename(index=str, columns={look_for_area_column: 'lf_area'}, inplace=True)
    objects_merged = objects.merge(look_for, on=id_column)  # merging dataframes together

    print('Calculating FAR...')

    # define empty list for results
    results_list = []

    # fill new column with the value of area, iterating over rows one by one
    for index, row in tqdm(objects_merged.iterrows(), total=objects_merged.shape[0]):
        results_list.append(row['lf_area'] / row[area_column])

    series = pd.Series(results_list)

    print('Floor area ratio calculated.')
    return series


def elements_count(aggr, elements, left_id, right_id, weighted=False):
    """
    Calculate the number of elements within aggregated structure.

    Aggregated structure can be typically block, street segment or street node. Elements has to have
    unique id of aggregated structure assigned before hand (e.g. using :py:func:`momepy.elements.get_network_id`).
    If weighted=True, number of elements will be divided by the area of lenght (based on geometry type) of aggregated
    element, to return relative value.

    .. math::
        \\sum_{i \\in aggr} (n_i);\\space \\frac{\\sum_{i \\in aggr} (n_i)}{area_{aggr}}

    Parameters
    ----------
    aggr : GeoDataFrame
        GeoDataFrame containing aggregation to analyse
    elements : GeoDataFrame
        GeoDataFrame containing elements to analyse
    left_id : str
        name of the column where is stored unique ID in aggr
    right_id : str
        name of the column where is stored unique ID of aggregation in elements gdf
    weighted : bool (default False)
        if weighted=True, count will be divided by the area or length

    Returns
    -------
    Series
        Series containing resulting values.

    References
    ---------
    Hermosilla T, Ruiz LA, Recio JA, et al. (2012) Assessing contextual descriptive features
    for plot-based classification of urban areas. Landscape and Urban Planning, Elsevier B.V.
    106(1): 124â€“137.
    Feliciotti A (2018) RESILIENCE AND URBAN DESIGN:A SYSTEMS APPROACH TO THE
    STUDY OF RESILIENCE IN URBAN FORM. LEARNING FROM THE CASE OF GORBALS. Glasgow.
    """
    count = collections.Counter(elements[right_id])
    df = pd.DataFrame.from_dict(count, orient='index', columns=['mm_count'])
    joined = aggr.join(df['mm_count'], on=left_id)
    joined['mm_count'][np.isnan(joined['mm_count'])] = 0

    if weighted:
        if aggr.geometry[0].type in ['Polygon', 'MultiPolygon']:
            joined['mm_count'] = joined['mm_count'] / aggr.geometry.area
        elif aggr.geometry[0].type in ['LineString', 'MultiLineString']:
            joined['mm_count'] = joined['mm_count'] / aggr.geometry.length
        else:
            raise TypeError('Geometry type does not support weighting.')

    return joined['mm_count']


def courtyards(objects, block_id, spatial_weights=None):
    """
    Calculate the number of courtyards within the joined structure.

    Parameters
    ----------
    objects : GeoDataFrame
        GeoDataFrame containing objects to analyse
    block_id : str
        name of the column where is stored block ID
    spatial_weights : libpysal.weights, optional
        spatial weights matrix - If None, Queen contiguity matrix will be calculated
        based on objects. It is to denote adjacent buildings.

    Returns
    -------
    Series
        Series containing resulting values.

    Notes
    -----
    Script is not optimised at all, so it is currently extremely slow.
    """
    # define empty list for results
    results_list = []

    print('Calculating courtyards...')

    if not all(objects.index == range(len(objects))):
        raise ValueError('Index is not consecutive range 0:x, spatial weights will not match objects.')

    # if weights matrix is not passed, generate it from objects
    if spatial_weights is None:
        print('Calculating spatial weights...')
        from libpysal.weights import Queen
        spatial_weights = Queen.from_dataframe(objects, silence_warnings=True)
        print('Spatial weights ready...')

    # dict to store nr of courtyards for each uID
    courtyards = {}

    for index, row in tqdm(objects.iterrows(), total=objects.shape[0]):
        # if the id is already present in courtyards, continue (avoid repetition)
        if index in courtyards:
            continue
        else:
            to_join = [index]  # list of indices which should be joined together
            neighbours = []  # list of neighbours
            weights = spatial_weights.neighbors[index]  # neighbours from spatial weights
            for w in weights:
                neighbours.append(w)  # make a list from weigths

            for n in neighbours:
                while n not in to_join:  # until there is some neighbour which is not in to_join
                    to_join.append(n)
                    weights = spatial_weights.neighbors[n]
                    for w in weights:
                        neighbours.append(w)  # extend neighbours by neighbours of neighbours :)
            joined = objects.iloc[to_join]
            dissolved = joined.geometry.buffer(0.01).unary_union  # buffer to avoid multipolygons where buildings touch by corners only
            try:
                interiors = len(list(dissolved.interiors))
            except(ValueError):
                print('Something happened.')
            for b in to_join:
                courtyards[b] = interiors  # fill dict with values
    # copy values from dict to gdf
    for index, row in tqdm(objects.iterrows(), total=objects.shape[0]):
        results_list.append(courtyards[index])

    series = pd.Series(results_list)
    print('Courtyards calculated.')
    return series


def gross_density(objects, buildings, area, character, spatial_weights=None, order=3, unique_id='uID'):
    """
    Calculate the density

    .. math::


    Parameters
    ----------
    objects : GeoDataFrame
        GeoDataFrame containing tessellation objects to analyse
    buildings : GeoDataFrame
        GeoDataFrame containing buildings
    area : str
        name of the column with area values
    character : str
        name of the column with values of target character for density calculation
    spatial_weights : libpysal.weights, optional
        spatial weights matrix - If None, Queen contiguity matrix of selected order will be calculated
        based on objects.
    order : int
        order of Queen contiguity
    unique_id : str
        name of the column with unique id. If there is none, it could be generated by unique_id()

    Returns
    -------
    Series
        Series containing resulting values.

    References
    ---------
    Jacob??

    Notes
    -----
    Rework, it is a mess. Terminology!
    """
    # define empty list for results
    results_list = []

    print('Calculating gross density...')

    if not all(objects.index == range(len(objects))):
        raise ValueError('Index is not consecutive range 0:x, spatial weights will not match objects.')

    if spatial_weights is None:
        print('Generating weights matrix (Queen) of {} topological steps...'.format(order))
        from momepy import Queen_higher
        # matrix to define area of analysis (more steps)
        spatial_weights = Queen_higher(k=order, geodataframe=objects)

    # iterating over rows one by one
    for index, row in tqdm(objects.iterrows(), total=objects.shape[0]):
        neighbours_id = spatial_weights.neighbors[index]
        neighbours_id.append(index)
        neighbours = objects.iloc[neighbours_id]

        fa = buildings.loc[buildings[unique_id].isin(neighbours[unique_id])][character]
        results_list.append(sum(fa) / sum(neighbours[area]))

    series = pd.Series(results_list)
    print('Gross density calculated.')
    return series


def blocks_count(tessellation, block_id, spatial_weights=None, order=5):
    """
    Calculates the weighted number of blocks

    Number of blocks within `k` topological steps defined in spatial_weights weighted by the analysed area.

    .. math::
        \\frac{\\sum_{i=1}^{n} {blocks}}{\\sum_{i=1}^{n} area_{i}}
        NOT SURE

    Parameters
    ----------
    tessellation : GeoDataFrame
        GeoDataFrame containing morphological tessellation
    block_id : str, list, np.array, pd.Series (default None)
        the name of the objects dataframe column, np.array, or pd.Series where is stored block ID.
    spatial_weights : libpysal.weights (default None)
        spatial weights matrix - If None, Queen contiguity matrix of set order will be calculated
        based on objects.
    order : int (default 5)
        order of Queen contiguity. Used only when spatial_weights=None.


    Returns
    -------
    Series
        Series containing resulting values.

    References
    ----------
    Jacob

    Examples
    --------

    Notes
    -----
    Blocks count or blocks density?

    """
    # define empty list for results
    results_list = []

    if not isinstance(block_id, str):
        block_id['mm_bid'] = block_id
        block_id = 'mm_bid'

    if not all(tessellation.index == range(len(tessellation))):
        raise ValueError('Index is not consecutive range 0:x, spatial weights will not match objects.')

    if spatial_weights is None:
        print('Generating weights matrix (Queen) of {} topological steps...'.format(order))
        from momepy import Queen_higher
        # matrix to define area of analysis (more steps)
        spatial_weights = Queen_higher(k=order, geodataframe=tessellation)

    print('Calculating blocks...')

    for index, row in tqdm(tessellation.iterrows(), total=tessellation.shape[0]):
        neighbours = spatial_weights.neighbors[index]
        neighbours.append(index)
        vicinity = tessellation.iloc[neighbours]

        results_list.append(len(set(list(vicinity[block_id]))) / sum(vicinity.geometry.area))

    series = pd.Series(results_list)

    if 'mm_bid' in tessellation.columns:
        tessellation.drop(columns=['mm_bid'], inplace=True)

    print('Blocks calculated.')
    return series


def reached(streets, elements, unique_id, spatial_weights=None, mode='count', values=None):
    """
    Calculates the number of elements reached within topological steps

    Number of elements within topological steps defined in spatial_weights. If
    spatial_weights are None, it will assume topological distance 0 (element itself).
    If mode='area', returns sum of areas of reached elements. Requires unique_id
    of streets assigned beforehand (e.g. using :py:func:`momepy.get_network_id`).

    .. math::


    Parameters
    ----------
    streets : GeoDataFrame
        GeoDataFrame containing streets (either segments or nodes)
    elements : GeoDataFrame
        GeoDataFrame containing elements to be counted
    unique_id : str, list, np.array, pd.Series (default None)
        the name of the objects dataframe column, np.array, or pd.Series where is
        stored ID of streets (segments or nodes).
    spatial_weights : libpysal.weights (default None)
        spatial weights matrix
    mode : str (default 'count')
        mode of calculation. If `'count'` function will return the count of reached elements.
        If `'sum'`, it will return sum of `'values'`. If `'mean'` it will return mean value
        of `'values'`. If `'std'` it will return standard deviation
        of `'values'`. If `'values'` not set it will use of areas
        of reached elements.
    values : str (default None)
        the name of the objects dataframe column with values used for calculations

    Returns
    -------
    Series
        Series containing resulting values.

    References
    ----------

    Examples
    --------

    """
    # define empty list for results
    results_list = []

    print('Calculating reached {}...'.format(mode))

    if not isinstance(unique_id, str):
        elements['mm_id'] = unique_id
        unique_id = 'mm_id'

    if mode == 'count':
        count = collections.Counter(elements[unique_id])

    # iterating over rows one by one
    for index, row in tqdm(streets.iterrows(), total=streets.shape[0]):
        if spatial_weights is None:
            ids = [row.nID]
        else:
            neighbours = spatial_weights.neighbors[index]
            neighbours.append(index)
            ids = streets.iloc[neighbours].nID
        if mode == 'count':
            counts = []
            for nid in ids:
                counts.append(count[nid])
            results_list.append(sum(counts))
        elif mode == 'sum':
            if values:
                results_list.append(sum(elements.loc[elements[unique_id].isin(ids)][values]))
            else:
                results_list.append(sum(elements.loc[elements[unique_id].isin(ids)].geometry.area))
        elif mode == 'mean':
            if values:
                results_list.append(np.nanmean(elements.loc[elements[unique_id].isin(ids)][values]))
            else:
                results_list.append(np.nanmean(elements.loc[elements[unique_id].isin(ids)].geometry.area))
        elif mode == 'std':
            if values:
                results_list.append(np.nanstd(elements.loc[elements[unique_id].isin(ids)][values]))
            else:
                results_list.append(np.nanstd(elements.loc[elements[unique_id].isin(ids)].geometry.area))

    series = pd.Series(results_list)
    if 'mm_id' in elements.columns:
        elements.drop(columns=['mm_id'], inplace=True)

    print('Reached {} calculated.'.format(mode))
    return series


def node_density(objects, nodes, spatial_weights=None, order=9, node_id='nodeID'):
    """
    Calculate the density of nodes within topological steps of morphological tessellation.
    Node is marked as reached if reached cell con

    .. math::


    Parameters
    ----------
    objects : GeoDataFrame
        GeoDataFrame containing tessellation objects to analyse
    nodes : GeoDataFrame
        GeoDataFrame containing nodes
    spatial_weights : libpysal.weights, optional
        spatial weights matrix - If None, Queen contiguity matrix of selected order will be calculated
        based on objects.
    order : int
        order of Queen contiguity
    node_id : str
        name of the column of objects gdf with node id.

    Returns
    -------
    Series
        Series containing resulting values.

    References
    ---------
    Jacob

    Notes
    -----

    """
    # define empty list for results
    results_list = []

    print('Calculating gross density...')

    if not all(objects.index == range(len(objects))):
        raise ValueError('Index is not consecutive range 0:x, spatial weights will not match objects.')

    if spatial_weights is None:
        print('Generating weights matrix (Queen) of {} topological steps...'.format(order))
        from momepy import Queen_higher
        # matrix to define area of analysis (more steps)
        spatial_weights = Queen_higher(k=order, geodataframe=objects)

    # iterating over rows one by one
    for index, row in tqdm(objects.iterrows(), total=objects.shape[0]):
        neighbours = spatial_weights.neighbors[index]
        neighbours.append(index)
        sub = objects.iloc[neighbours]
        subnodes = set(sub['nodeID'])
        results_list.append((len(subnodes) / sum(sub.geometry.area)) * 10000)

    series = pd.Series(results_list)
    print('Gross density calculated.')
    return series
